# HTTP的缓存控制

> #### “Cache-Control” 头字段的属性

“**Cache-Control**” 有如下几个属性值：

“**max-age=xxx**” 表示资源的有效时间，这个时间如果是服务器端设置的就从创建报文的时间开始计算，例如：服务器设置的是15秒（“max-age=15” ），可能在传输的过程中就浪费了2秒，实际在客户端的生效时间就是13秒。

“**no-store**” 表示不允许设置缓存，通常用于某些变化频繁的资源

“**no-cache**” 表示每次使用缓存前必须要去服务器检查是否有最新版本，没有则使用缓存，有则获取最新版本

“**no-revalidate**” 表示有效时间内可以继续使用，一旦过期了如果还想使用就必须去服务器验证

![](./img/cache_01.png)

> #### “Cache-Control” 头字段的使用

**“Cache-Control” 响应头字段 在服务器端设置**：

1、浏览器发现资源没有缓存，于是发生请求向服务器获取资源

2、服务器响应请求，并且在响应设置 “Cache-Control: max-age=20”

3、浏览器缓存资源，下次如果在有效期内（30 - 报文传输时间）重复请求该资源浏览器则优先使用缓存资源

**“Cache-Control” 响应头字段 在客户端设置**：

1、在浏览器点击 “刷新” 按钮的时候，浏览器会在请求头添加 “Cache-Control: max-age=0” 表示要去服务器获取最新资源，不管该资源是否有缓存

2、按 “Ctrl+F5” 强制刷新时候，浏览器会在请求头添加 “Cache-Control: no-cache” 其实也是表示获取最新的资源

3、在浏览器点击 “前进”、“后退” 按钮的时候，浏览器压根就不设置 “Cache-Control” 头字段，打开发者工具 在 “Status Code” 头字段上你会惊喜的发现 “from disk cache”，意思是压根就没有走网络请求，直接使用缓存

> #### 条件请求

通过对 “Cache-Control” 头字段的分析发现它对缓存的控制并不是很实用，又因为缓存会失效、使用前必须去检查服务器是否有新版本（两次请求浪费资源）等原因，所以 HTTP 协议就定义了一系列 “if” 开头的 “条件请求” 头字段，专门用来检查资源是否有过期，把验证的过程交给服务器，提高使用效率。

**条件请求** 需要第一次请求资源的时候返回 “**Last-modified**” , “**ETag**” 头字段，再次请求的时候在 “**条件请求**” 头字段上带上相应的 “**Last-modified**” , “**ETag**” 的值用来验证请求资源是否已更新。

“**Last-modified**” 表示资源文件的最后修改时间

“**ETag**” 是 “实体标签（Entity Tag）” 的缩写，就是资源的hash值，用来验证资源是否有变化，资源有变化相应hash值就不一样

1、“**if-Modified-Since: Last-modified**” 表示使用“Last-modified” 来判断资源文件是否有更新，没有就使用缓存，有就获取最新的

2、“**if-None-Match: ETag**” 表示 使用 “ETag” 来判断资源文件是否有更新，没有就使用缓存，有就获取最新的